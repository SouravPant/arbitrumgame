<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARBITAP - Tap to Earn</title>

    <!-- Farcaster Mini App Metadata -->
    <meta name="fc:miniapp" content='{
      "version": "1",
      "imageUrl": "https://arbitrumgame.vercel.app/image.png",
      "button": {
        "title": "Play ARBITAP",
        "action": {
          "type": "launch_frame",
          "name": "ARBITAP",
          "url": "https://arbitrumgame.vercel.app",
          "splashImageUrl": "https://arbitrumgame.vercel.app/splash.png",
          "splashBackgroundColor": "#28a0f0"
        }
      }
    }' />

    <style>
        :root {
            --primary-blue: #007AFF;
            --secondary-blue: #5AC8FA;
            --neon-cyan: #00FFFF;
            --neon-purple: #8A2BE2;
            --background: #000014;
            --surface: #1C1C1E;
            --surface-light: #2C2C2E;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --gold: #FFD700;
            --green: #30D158;
            --red: #FF3B30;
            --orange: #FF9500;
            --notcoin-yellow: #FFD60A;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, var(--background) 0%, #001122 100%);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            user-select: none;
            overflow-x: hidden;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            max-width: 480px;
            margin: 0 auto;
        }

        /* Header with Balance and Level */
        .header {
            padding: 20px 20px 15px;
            background: rgba(28, 28, 30, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .app-title {
            font-size: 24px;
            font-weight: 800;
            background: linear-gradient(45deg, var(--primary-blue), var(--neon-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .wallet-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .wallet-status {
            font-size: 12px;
            color: var(--green);
            background: rgba(48, 209, 88, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(48, 209, 88, 0.3);
            cursor: pointer;
        }

        .balance-display {
            text-align: center;
            margin-bottom: 15px;
        }

        .balance-value {
            font-size: 36px;
            font-weight: 800;
            color: var(--gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            margin-bottom: 5px;
        }

        .balance-label {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .level-section {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 122, 255, 0.1);
            border-radius: 16px;
            padding: 12px 16px;
            border: 1px solid rgba(0, 122, 255, 0.2);
        }

        .level-text {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary-blue);
            min-width: 70px;
        }

        .level-progress {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-blue), var(--neon-cyan));
            border-radius: 4px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            width: 0%;
        }

        .next-level {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        /* Energy System */
        .energy-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 12px;
        }

        .energy-icon {
            font-size: 18px;
            animation: energyPulse 2s ease-in-out infinite;
        }

        .energy-bar {
            width: 140px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--neon-cyan));
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 100%;
        }

        .energy-text {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
            min-width: 60px;
        }

        @keyframes energyPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Central Tap Section */
        .tap-section {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            position: relative;
            min-height: 250px;
        }

        .tap-button {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--neon-cyan) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 20px 60px rgba(0, 122, 255, 0.4),
                0 0 0 4px rgba(255, 255, 255, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            border: none;
            outline: none;
            animation: tapButtonGlow 3s ease-in-out infinite;
        }

        .tap-button:active {
            transform: scale(0.95);
            animation: tapPulse 0.6s ease-out;
        }

        .tap-icon {
            font-size: 70px;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
            transition: transform 0.2s ease;
        }

        @keyframes tapButtonGlow {
            0%, 100% {
                box-shadow:
                    0 20px 60px rgba(0, 122, 255, 0.4),
                    0 0 0 4px rgba(255, 255, 255, 0.1),
                    inset 0 2px 0 rgba(255, 255, 255, 0.2);
            }
            50% {
                box-shadow:
                    0 25px 80px rgba(0, 255, 255, 0.6),
                    0 0 0 6px rgba(0, 255, 255, 0.3),
                    inset 0 2px 0 rgba(255, 255, 255, 0.3);
            }
        }

        @keyframes tapPulse {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Power-ups Section */
        .powerups-section {
            padding: 20px;
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
            color: var(--text-primary);
        }

        .powerups-scroll {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 5px 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .powerups-scroll::-webkit-scrollbar {
            display: none;
        }

        .powerup-card {
            min-width: 120px;
            background: rgba(44, 44, 46, 0.8);
            border-radius: 16px;
            padding: 16px 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .powerup-card:hover {
            transform: translateY(-4px);
            background: rgba(0, 122, 255, 0.1);
            border-color: var(--primary-blue);
        }

        .powerup-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .powerup-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .powerup-level {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .powerup-cost {
            font-size: 11px;
            font-weight: 600;
            color: var(--gold);
        }

        /* Leaderboard Section */
        .leaderboard-section {
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px 16px 0 0;
            margin-top: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .leaderboard-toggle {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 16px 20px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .leaderboard-toggle:hover {
            background: rgba(0, 122, 255, 0.1);
        }

        .toggle-icon {
            transition: transform 0.3s ease;
            font-size: 14px;
        }

        .leaderboard-toggle.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .leaderboard-content {
            max-height: 800px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }

        .leaderboard-content.collapsed {
            max-height: 0;
        }

        .leaderboard-list {
            padding: 0 20px 20px;
            max-height: 750px;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(44, 44, 46, 0.6);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-item.current-player {
            background: linear-gradient(90deg, rgba(0, 122, 255, 0.2) 0%, rgba(44, 44, 46, 0.8) 100%);
            border-color: var(--primary-blue);
        }

        .rank {
            font-size: 16px;
            font-weight: 800;
            color: var(--text-primary);
            min-width: 30px;
        }

        .player-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-blue), var(--neon-purple));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: white;
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .player-stats {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .player-score {
            font-size: 14px;
            color: var(--gold);
            font-weight: 700;
        }

        /* Animations for tap effects */
        .tap-popup {
            position: absolute;
            font-size: 24px;
            font-weight: 800;
            color: var(--gold);
            pointer-events: none;
            animation: popupFloat 1.5s ease-out forwards;
            z-index: 1000;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        @keyframes popupFloat {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(-40px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1);
            }
        }

        /* Wallet Connection Specific Styles */
        .connect-wallet-btn {
            padding: 12px 24px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .connect-wallet-btn:hover {
            background: var(--secondary-blue);
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .wallet-address {
            font-weight: 600;
        }

        .farcaster-status {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        /* Network Status Styles */
        .network-status {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 12px;
            color: #fff;
            border: 1px solid rgba(255, 165, 0, 0.3);
            transition: all 0.3s ease;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 360px) {
            .container {
                max-width: 100%;
            }

            .header {
                padding: 15px;
            }

            .app-title {
                font-size: 20px;
            }

            .balance-value {
                font-size: 28px;
            }

            .tap-button {
                width: 160px;
                height: 160px;
            }

            .tap-icon {
                font-size: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header with Balance and Level -->
        <div class="header">
            <div class="header-top">
                <div class="app-title">ARBITAP</div>
                <div class="wallet-info">
                    <div class="wallet-status" id="walletStatus">Connect Wallet</div>
                    <div id="networkStatus" class="network-status">
                        <span id="networkIcon">🟡</span>
                        <span id="networkText">Arbitrum Sepolia (Testnet)</span>
                    </div>
                </div>
            </div>

            <div class="balance-display">
                <div class="balance-value" id="totalTaps">0</div>
                <div class="balance-label">Total Taps</div>
            </div>

            <div class="level-section">
                <div class="level-text" id="currentLevel">Level 1</div>
                <div class="level-progress">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="next-level" id="nextLevel">Level 2</div>
            </div>

            <div class="energy-section">
                <span class="energy-icon">⚡</span>
                <div class="energy-bar">
                    <div class="energy-fill" id="energyFill"></div>
                </div>
                <span class="energy-text" id="energyText">1000/1000</span>
            </div>
        </div>

        <!-- Central Tap Section -->
        <div class="tap-section">
            <button class="tap-button" id="tapButton">
                <div class="tap-icon">⚡</div>
            </button>
        </div>

        <!-- Power-ups Section -->
        <div class="powerups-section">
            <div class="section-title">⚡ Power-ups</div>
            <div class="powerups-scroll">
                <div class="powerup-card" id="tapPowerUpgrade">
                    <div class="powerup-icon">👆</div>
                    <div class="powerup-name">Tap Power</div>
                    <div class="powerup-level">Level <span id="tapPowerLevel">1</span></div>
                    <div class="powerup-cost"><span id="tapPowerCost">100</span> taps</div>
                </div>
                <div class="powerup-card" id="energyUpgrade">
                    <div class="powerup-icon">🔋</div>
                    <div class="powerup-name">Max Energy</div>
                    <div class="powerup-level">Level <span id="energyLevel">1</span></div>
                    <div class="powerup-cost"><span id="energyCost">200</span> taps</div>
                </div>
                <div class="powerup-card" id="regenUpgrade">
                    <div class="powerup-icon">⚡</div>
                    <div class="powerup-name">Energy Regen</div>
                    <div class="powerup-level">Level <span id="regenLevel">1</span></div>
                    <div class="powerup-cost"><span id="regenCost">300</span> taps</div>
                </div>
                <div class="powerup-card" id="levelUpgrade">
                    <div class="powerup-icon">⬆️</div>
                    <div class="powerup-name">Level Up</div>
                    <div class="powerup-level">Next: <span id="nextLevelCost">1000</span></div>
                    <div class="powerup-cost"><span id="levelUpCost">1000</span> taps</div>
                </div>
                <!-- New Power-up Card -->
                <div class="powerup-card" id="manualContractSync">
                    <div class="powerup-icon">🔗</div>
                    <div class="powerup-name">Sync Wallet</div>
                    <div class="powerup-level">Cost: 1 tap</div>
                    <div class="powerup-cost">1 tap</div>
                </div>
            </div>
        </div>

        <!-- Leaderboard Section -->
        <div class="leaderboard-section">
            <button class="leaderboard-toggle" id="leaderboardToggle">
                <span>🏆 Global Leaderboard</span>
                <span class="toggle-icon">▼</span>
            </button>
            <div class="leaderboard-content" id="leaderboardContent">
                <div class="leaderboard-list" id="leaderboardList">
                    <!-- Leaderboard items will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Game Script -->
    <script>
        // Game Configuration
        const LEVEL_REQUIREMENTS = [
            0, 100, 300, 600, 1000, 1500, 2100, 2800, 3600, 4500,
            5500, 6600, 7800, 9100, 10500, 12000, 13600, 15300, 17100, 19000
        ];

        // Network Configurations with Alchemy API support
        const NETWORKS = {
            ARBITRUM_ONE: {
                chainId: '0xa4b1', // 42161 in hex
                name: 'Arbitrum One',
                rpcUrls: [
                    'https://arb-mainnet.g.alchemy.com/v2/demo',
                    'https://arb1.arbitrum.io/rpc',
                    'https://arbitrum-one.publicnode.com'
                ],
                blockExplorerUrls: ['https://arbiscan.io'],
                contractAddress: '0xF3FF71531F523f09c42490760e9Ba43eD30bb0De',
                nativeCurrency: {
                    name: 'Ether',
                    symbol: 'ETH',
                    decimals: 18
                }
            },
            ARBITRUM_SEPOLIA: {
                chainId: '0x66eee', // 421614 in hex
                name: 'Arbitrum Sepolia',
                rpcUrls: [
                    'https://arb-sepolia.g.alchemy.com/v2/demo',
                    'https://sepolia-rollup.arbitrum.io/rpc',
                    'https://arbitrum-sepolia.publicnode.com'
                ],
                blockExplorerUrls: ['https://sepolia.arbiscan.io'],
                contractAddress: '0xF3FF71531F523f09c42490760e9Ba43eD30bb0De',
                nativeCurrency: {
                    name: 'Ether',
                    symbol: 'ETH',
                    decimals: 18
                }
            }
        };

        // Set default network to Arbitrum Sepolia (Testnet)
        // You can change this to NETWORKS.ARBITRUM_ONE to connect to Mainnet
        let CURRENT_NETWORK = NETWORKS.ARBITRUM_SEPOLIA;

        // Contract ABI and address from deployed contract
        const CONTRACT_ABI = [
            {
                "inputs": [{"internalType": "uint256", "name": "newLevel", "type": "uint256"}],
                "name": "updateLevel",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "newTapCount", "type": "uint256"}],
                "name": "updateTaps",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "uint256", "name": "milestone", "type": "uint256"}],
                "name": "mintNFT",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "player", "type": "address"}],
                "name": "getPlayerStats",
                "outputs": [
                    {"internalType": "uint256", "name": "totalTaps", "type": "uint256"},
                    {"internalType": "uint256", "name": "currentLevel", "type": "uint256"},
                    {"internalType": "uint256", "name": "nftsMinted", "type": "uint256"},
                    {"internalType": "uint256", "name": "lastMintTimestamp", "type": "uint256"},
                    {"internalType": "uint256", "name": "lastLevelUpTimestamp", "type": "uint256"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "player", "type": "address"}],
                "name": "getNextMilestone",
                "outputs": [
                    {"internalType": "uint256", "name": "nextMilestone", "type": "uint256"},
                    {"internalType": "uint256", "name": "remainingTaps", "type": "uint256"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getMilestonesAndRewards",
                "outputs": [
                    {"internalType": "uint256[]", "name": "_milestones", "type": "uint256[]"},
                    {"internalType": "uint256[]", "name": "_rewards", "type": "uint256[]"}
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Game State
        let gameState = {
            totalTaps: 0,
            currentLevel: 1,
            tapPower: 1,
            energy: 1000,
            maxEnergy: 1000,
            energyRegenRate: 1,
            tapPowerLevel: 1,
            energyLevel: 1,
            regenLevel: 1,
            tapPowerCost: 100,
            energyCost: 200,
            regenCost: 300,
            levelUpCost: 1000, // This will be dynamically calculated
            walletConnected: false,
            walletAddress: null,
            contractAddress: CURRENT_NETWORK.contractAddress
        };

        // Sample leaderboard data - Top 15 players
        let leaderboardData = [
            { name: 'TapMaster_Pro', score: 1234567, level: 25, avatar: 'T' },
            { name: 'CryptoTapper', score: 987654, level: 22, avatar: 'C' },
            { name: 'ArbiKing', score: 765432, level: 19, avatar: 'A' },
            { name: 'Web3_Wizard', score: 542109, level: 16, avatar: 'W' },
            { name: 'DiamondHands', score: 298765, level: 13, avatar: 'D' },
            { name: 'MoonTapper', score: 187432, level: 11, avatar: 'M' },
            { name: 'FastFingers', score: 156789, level: 10, avatar: 'F' },
            { name: 'TapLegend', score: 134521, level: 9, avatar: 'L' },
            { name: 'ClickMaster', score: 98765, level: 8, avatar: 'K' },
            { name: 'PowerTapper', score: 87654, level: 8, avatar: 'P' },
            { name: 'SpeedDemon', score: 76543, level: 7, avatar: 'S' },
            { name: 'TapWizard', score: 65432, level: 7, avatar: 'Z' },
            { name: 'FingerFlash', score: 54321, level: 6, avatar: 'G' },
            { name: 'TapNinja', score: 43210, level: 6, avatar: 'N' },
            { name: 'ClickChamp', score: 32109, level: 5, avatar: 'H' }
        ];

        // DOM Elements
        let elements = {};

        // Global wallet connection state
        let isWalletConnected = false;
        let connectedAddress = null;

        // Load contract instance
        let gameContract = null;

        // Initialize elements
        function initializeElements() {
            elements = {
                totalTaps: document.getElementById('totalTaps'),
                currentLevel: document.getElementById('currentLevel'),
                nextLevel: document.getElementById('nextLevel'),
                progressBar: document.getElementById('progressBar'),
                tapButton: document.getElementById('tapButton'),
                energyFill: document.getElementById('energyFill'),
                energyText: document.getElementById('energyText'),
                leaderboardToggle: document.getElementById('leaderboardToggle'),
                leaderboardContent: document.getElementById('leaderboardContent'),
                leaderboardList: document.getElementById('leaderboardList'),
                tapPowerLevel: document.getElementById('tapPowerLevel'),
                energyLevel: document.getElementById('energyLevel'),
                regenLevel: document.getElementById('regenLevel'),
                tapPowerCost: document.getElementById('tapPowerCost'),
                energyCost: document.getElementById('energyCost'),
                regenCost: document.getElementById('regenCost'),
                levelUpCost: document.getElementById('levelUpCost'), // This is the one to update for display
                walletStatus: document.getElementById('walletStatus'),
                connectWalletBtn: document.getElementById('connectWalletBtn'),
                networkStatus: document.getElementById('networkStatus'),
                networkText: document.getElementById('networkText'),
                networkIcon: document.getElementById('networkIcon'),
                manualContractSync: document.getElementById('manualContractSync') // Added for the new power-up
            };

            console.log('Elements initialized:', {
                tapButton: !!elements.tapButton,
                totalTaps: !!elements.totalTaps,
                leaderboardToggle: !!elements.leaderboardToggle,
                connectWalletBtn: !!elements.connectWalletBtn,
                networkStatus: !!elements.networkStatus,
                manualContractSync: !!elements.manualContractSync // Check for the new element
            });
        }

        // Format numbers
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        // Calculate level from taps
        function calculateLevel(taps) {
            for (let i = LEVEL_REQUIREMENTS.length - 1; i >= 0; i--) {
                if (taps >= LEVEL_REQUIREMENTS[i]) {
                    return i + 1;
                }
            }
            return 1;
        }

        // Calculate progress to next level
        function calculateProgress(taps, level) {
            if (level >= LEVEL_REQUIREMENTS.length) return 100;

            const currentReq = LEVEL_REQUIREMENTS[level - 1];
            const nextReq = LEVEL_REQUIREMENTS[level];
            const progress = ((taps - currentReq) / (nextReq - currentReq)) * 100;

            return Math.min(100, Math.max(0, progress));
        }

        // Update UI
        function updateUI() {
            const newLevel = calculateLevel(gameState.totalTaps);
            if (newLevel > gameState.currentLevel) {
                gameState.currentLevel = newLevel;
                gameState.tapPower = Math.max(gameState.tapPowerLevel, Math.floor(newLevel / 5) + 1);
                showNotification(`🎉 Level Up! Welcome to Level ${newLevel}`);
            }

            // Update display elements
            if (elements.totalTaps) {
                elements.totalTaps.textContent = formatNumber(gameState.totalTaps);
            }

            if (elements.currentLevel) {
                elements.currentLevel.textContent = `Level ${gameState.currentLevel}`;
            }

            if (elements.nextLevel) {
                const nextLvl = gameState.currentLevel + 1;
                elements.nextLevel.textContent = nextLvl <= LEVEL_REQUIREMENTS.length ? `Level ${nextLvl}` : 'MAX';
            }

            if (elements.progressBar) {
                const progress = calculateProgress(gameState.totalTaps, gameState.currentLevel);
                elements.progressBar.style.width = progress + '%';
            }

            // Update energy
            if (elements.energyFill) {
                const energyPercent = (gameState.energy / gameState.maxEnergy) * 100;
                elements.energyFill.style.width = energyPercent + '%';
            }

            if (elements.energyText) {
                elements.energyText.textContent = `${Math.floor(gameState.energy)}/${gameState.maxEnergy}`;
            }

            // Update power-up costs and levels
            if (elements.tapPowerLevel) elements.tapPowerLevel.textContent = gameState.tapPowerLevel;
            if (elements.energyLevel) elements.energyLevel.textContent = gameState.energyLevel;
            if (elements.regenLevel) elements.regenLevel.textContent = gameState.regenLevel;
            if (elements.tapPowerCost) elements.tapPowerCost.textContent = formatNumber(gameState.tapPowerCost);
            if (elements.energyCost) elements.energyCost.textContent = formatNumber(gameState.energyCost);
            if (elements.regenCost) elements.regenCost.textContent = formatNumber(gameState.regenCost);

            // Update level up cost display - calculate based on next level requirements
            const nextLevel = gameState.currentLevel + 1;
            const requiredTapsForNextLevel = nextLevel * nextLevel * 100; // Match contract formula
            const remainingTapsNeeded = Math.max(0, requiredTapsForNextLevel - gameState.totalTaps);

            if (elements.levelUpCost) {
                if (remainingTapsNeeded > 0) {
                    elements.levelUpCost.textContent = `${formatNumber(remainingTapsNeeded)} more taps`;
                } else {
                    elements.levelUpCost.textContent = "Ready!";
                }
            }

            // Update next level cost display
            if (document.getElementById('nextLevelCost')) {
                document.getElementById('nextLevelCost').textContent = formatNumber(requiredTapsForNextLevel);
            }

            updateLeaderboard();
            saveGameState();
        }

        // Handle tap
        function handleTap(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Check if enough energy
            if (gameState.energy < gameState.tapPower) {
                showNotification('⚡ Not enough energy!');
                return;
            }

            // Update game state
            gameState.energy -= gameState.tapPower;
            gameState.totalTaps += gameState.tapPower;

            console.log('Tap! Total taps:', gameState.totalTaps, 'Energy:', gameState.energy);

            // Visual feedback
            createTapPopup();

            // Haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }

            // Update UI immediately
            updateUI();
        }

        // Create tap popup
        function createTapPopup() {
            const popup = document.createElement('div');
            popup.className = 'tap-popup';
            popup.textContent = `+${gameState.tapPower}`;

            const buttonRect = elements.tapButton.getBoundingClientRect();
            const x = buttonRect.left + (Math.random() * buttonRect.width);
            const y = buttonRect.top + (Math.random() * buttonRect.height);

            popup.style.left = x + 'px';
            popup.style.top = y + 'px';

            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1500);
        }

        // Update leaderboard
        function updateLeaderboard() {
            if (!elements.leaderboardList) return;

            // Add current player to leaderboard
            const playerData = {
                name: 'You',
                score: gameState.totalTaps,
                level: gameState.currentLevel,
                avatar: 'Y',
                isCurrentPlayer: true
            };

            const allPlayers = [...leaderboardData, playerData].sort((a, b) => b.score - a.score);

            console.log(`Updating leaderboard with ${allPlayers.length} players`);

            elements.leaderboardList.innerHTML = allPlayers.map((player, index) => {
                const rank = index + 1;
                const currentPlayerClass = player.isCurrentPlayer ? 'current-player' : '';

                return `
                    <div class="leaderboard-item ${currentPlayerClass}">
                        <div class="rank">${rank}</div>
                        <div class="player-avatar">${player.avatar}</div>
                        <div class="player-info">
                            <div class="player-name">${player.name}</div>
                            <div class="player-stats">Level ${player.level}</div>
                        </div>
                        <div class="player-score">${formatNumber(player.score)}</div>
                    </div>
                `;
            }).join('');

            console.log(`Leaderboard HTML length: ${elements.leaderboardList.innerHTML.length} characters`);
        }

        // Energy regeneration
        function startEnergyRegen() {
            setInterval(() => {
                if (gameState.energy < gameState.maxEnergy) {
                    gameState.energy = Math.min(gameState.maxEnergy, gameState.energy + gameState.energyRegenRate);
                    updateUI();
                }
            }, 1000);
        }

        // Save game state
        function saveGameState() {
            localStorage.setItem('arbitapGameState', JSON.stringify(gameState));
        }

        // Load game state
        function loadGameState() {
            const saved = localStorage.getItem('arbitapGameState');
            if (saved) {
                const parsedState = JSON.parse(saved);
                // Merge loaded state, ensuring existing properties are preserved
                gameState = { ...gameState, ...parsedState };
                // Ensure costs are numbers after parsing
                gameState.tapPowerCost = Number(gameState.tapPowerCost);
                gameState.energyCost = Number(gameState.energyCost);
                gameState.regenCost = Number(gameState.regenCost);
                gameState.levelUpCost = Number(gameState.levelUpCost); // This might not be needed if it's always calculated
            }
        }

        // Show notification
        function showNotification(message, color = '#007AFF') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 12px;
                z-index: 1000;
                font-weight: 600;
                animation: slideDown 0.3s ease;
                opacity: 0;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Trigger reflow to enable animation
            requestAnimationFrame(() => {
                notification.style.opacity = '1';
            });

            setTimeout(() => {
                notification.style.animation = 'slideUp 0.3s ease';
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }

        // Function to update wallet status display
        function updateWalletStatus(connected, address = null) {
            const walletStatusDisplay = document.getElementById('walletStatus'); // Use the correct ID

            if (connected && address) {
                if (elements.connectWalletBtn) elements.connectWalletBtn.style.display = 'none';
                if (walletStatusDisplay) walletStatusDisplay.textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
                if (walletStatusDisplay) walletStatusDisplay.style.color = 'var(--green)'; // Indicate connected

                // Update global state
                isWalletConnected = true;
                connectedAddress = address;

                // Update game state
                gameState.walletConnected = true;
                gameState.walletAddress = address;

                // Update UI to reflect new level costs if wallet is connected
                updateUI();

                // Save updated game data
                saveGameState();

                console.log('Wallet connected:', address);
            } else {
                if (elements.connectWalletBtn) elements.connectWalletBtn.style.display = 'block';
                if (walletStatusDisplay) walletStatusDisplay.textContent = 'Connect Wallet';
                if (walletStatusDisplay) walletStatusDisplay.style.color = 'var(--text-secondary)'; // Indicate disconnected

                // Update global state
                isWalletConnected = false;
                connectedAddress = null;

                // Update game state
                gameState.walletConnected = false;
                gameState.walletAddress = null;

                console.log('Wallet disconnected');
            }
        }

        // Function to update network status display
        function updateNetworkStatus(networkInfo) {
            if (!elements.networkStatus || !elements.networkText || !elements.networkIcon) return;

            elements.networkText.textContent = `${networkInfo.name} (${networkInfo.isTestnet ? 'Testnet' : 'Mainnet'})`;
            elements.networkIcon.textContent = networkInfo.isTestnet ? '🧪' : '🌐';
            elements.networkStatus.style.borderColor = networkInfo.isTestnet ? 'var(--orange)' : 'var(--primary-blue)';
            console.log(`Network updated: ${networkInfo.name}`);
        }


        // Manual wallet connection function
        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('Please install MetaMask or another Web3 wallet to connect.');
                    return false;
                }

                console.log('MetaMask detected, requesting accounts...');
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });

                if (accounts.length > 0) {
                    const address = accounts[0];
                    console.log('Wallet connected successfully:', address);

                    // Check and switch to the target network if needed
                    await switchToTargetNetwork();

                    // After potential switch, re-check current network and update status
                    await updateCurrentNetworkInfo();

                    updateWalletStatus(true, address);

                    // Initialize contract after successful wallet connection
                    showNotification('Initializing contract...', '#00bfff');
                    setTimeout(async () => {
                        await initializeContract();
                    }, 1000);

                    return true;
                } else {
                    console.warn('No accounts found after requesting.');
                    alert('Could not connect to wallet. Please ensure MetaMask is unlocked and try again.');
                    return false;
                }
            } catch (error) {
                console.error('Wallet connection failed:', error);
                if (error.code === 4001) {
                    alert('Connection rejected. Please approve the connection in your wallet.');
                } else {
                    alert(`Failed to connect wallet: ${error.message}. Please try again.`);
                }
                return false;
            }
        }

        // Switch to the target network (defined by CURRENT_NETWORK)
        async function switchToTargetNetwork() {
            const targetChainId = CURRENT_NETWORK.chainId;

            if (typeof window.ethereum === 'undefined') {
                console.error('Ethereum provider not found.');
                showNotification('Please install MetaMask or another Web3 wallet.', '#ff3b30');
                return;
            }

            try {
                const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (currentChainId === targetChainId) {
                    console.log(`Already on ${CURRENT_NETWORK.name}.`);
                    showNotification(`Already connected to ${CURRENT_NETWORK.name}`, '#30d158');
                    return;
                }

                showNotification(`Switching to ${CURRENT_NETWORK.name}...`, '#00bfff');

                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: targetChainId }],
                });
                
                console.log(`Switched to ${CURRENT_NETWORK.name}.`);
                showNotification(`✅ Switched to ${CURRENT_NETWORK.name}`, '#30d158');
                
                // Re-initialize contract after network switch
                setTimeout(async () => {
                    await initializeContract();
                }, 1000);
                
            } catch (error) {
                console.error('Network switch error:', error);
                
                if (error.code === 4902) {
                    console.log(`Network ${CURRENT_NETWORK.name} not added, attempting to add...`);
                    showNotification(`Adding ${CURRENT_NETWORK.name} network...`, '#ffd700');
                    
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: targetChainId,
                                chainName: CURRENT_NETWORK.name,
                                nativeCurrency: CURRENT_NETWORK.nativeCurrency,
                                rpcUrls: CURRENT_NETWORK.rpcUrls,
                                blockExplorerUrls: CURRENT_NETWORK.blockExplorerUrls,
                                iconUrls: ['https://arbiscan.io/images/svg/brands/arbitrum.svg'] // Arbitrum icon
                            }],
                        });
                        
                        console.log(`Added ${CURRENT_NETWORK.name} network successfully.`);
                        showNotification(`✅ Added ${CURRENT_NETWORK.name} network`, '#30d158');
                        
                        // Retry switching after adding
                        setTimeout(async () => {
                            await switchToTargetNetwork();
                        }, 1000);
                        
                    } catch (addError) {
                        console.error(`Failed to add ${CURRENT_NETWORK.name} network:`, addError);
                        showNotification(`Failed to add ${CURRENT_NETWORK.name}. Please add manually in MetaMask.`, '#ff3b30');
                    }
                } else if (error.code === 4001) {
                    showNotification('Network switch rejected by user.', '#ff9900');
                } else {
                    console.error(`Failed to switch to ${CURRENT_NETWORK.name}:`, error);
                    showNotification(`Failed to switch networks. Please switch to ${CURRENT_NETWORK.name} manually.`, '#ff3b30');
                }
            }
        }

        // Initialize contract instance
        async function initializeContract() {
            try {
                console.log('Loading ethers.js...');
                await loadEthersLibrary();

                if (typeof window.ethereum === 'undefined') {
                    console.warn('Web3 provider not available. Contract features disabled.');
                    showNotification('Install MetaMask for blockchain features', '#ff9900');
                    return;
                }

                if (typeof window.ethers === 'undefined') {
                    console.error('ethers.js failed to load. Contract features disabled.');
                    showNotification('Failed to load blockchain library', '#ff3b30');
                    return;
                }

                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const network = await provider.getNetwork();

                console.log(`Connected to network: ${network.name} Chain ID: ${network.chainId}`);

                // Update current network based on what we're actually connected to
                const currentChainId = '0x' + network.chainId.toString(16);

                // Auto-detect and set the correct network
                if (currentChainId === NETWORKS.ARBITRUM_ONE.chainId) {
                    CURRENT_NETWORK = NETWORKS.ARBITRUM_ONE;
                    console.log('Detected Arbitrum One (Mainnet)');
                } else if (currentChainId === NETWORKS.ARBITRUM_SEPOLIA.chainId || network.chainId === 421614) {
                    CURRENT_NETWORK = NETWORKS.ARBITRUM_SEPOLIA;
                    console.log('Detected Arbitrum Sepolia (Testnet)');
                } else {
                    console.warn(`Unsupported network: ${network.name} (Chain ID: ${network.chainId})`);
                    showNotification(`Please switch to Arbitrum Sepolia testnet`, '#ff9900');
                    return;
                }

                // Update network status display
                updateNetworkStatus({
                    ...CURRENT_NETWORK,
                    isTestnet: CURRENT_NETWORK === NETWORKS.ARBITRUM_SEPOLIA
                });

                // Verify contract deployment on detected network
                const isContractDeployed = await verifyContractDeployment();
                if (!isContractDeployed) {
                    console.error('Contract verification failed');
                    return;
                }

                // Initialize game contract with network-specific address
                const contractAddress = CURRENT_NETWORK.contractAddress;
                const signer = provider.getSigner();
                gameContract = new window.ethers.Contract(contractAddress, CONTRACT_ABI, signer);

                console.log('Game contract initialized successfully with address:', contractAddress);
                showNotification(`✅ Contract initialized on ${CURRENT_NETWORK.name}`, '#30d158');

            } catch (error) {
                console.error('Failed to initialize contract:', error);
                showNotification('Blockchain connection failed. Using local mode.', '#ff9900');
            }
        }

        // Verify contract is deployed on current network
        async function verifyContractDeployment() {
            if (!CURRENT_NETWORK.contractAddress) {
                console.warn(`No contract deployed on ${CURRENT_NETWORK.name}`);
                showNotification(`⚠️ Contract not deployed on ${CURRENT_NETWORK.name}`, '#ff9900');
                return false;
            }

            try {
                await loadEthersLibrary();

                if (typeof window.ethereum === 'undefined' || typeof window.ethers === 'undefined') {
                    return false;
                }

                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const code = await provider.getCode(CURRENT_NETWORK.contractAddress);

                if (code === '0x') {
                    console.error(`Contract not found at ${CURRENT_NETWORK.contractAddress} on ${CURRENT_NETWORK.name}`);
                    showNotification(`❌ Contract not found on ${CURRENT_NETWORK.name}`, '#ff3b30');
                    return false;
                } else {
                    console.log(`✅ Contract verified at ${CURRENT_NETWORK.contractAddress} on ${CURRENT_NETWORK.name}`);
                    showNotification(`✅ Connected to ${CURRENT_NETWORK.name}`, '#30d158');
                    return true;
                }
            } catch (error) {
                console.error('Contract verification failed:', error);
                showNotification('Contract verification failed', '#ff3b30');
                return false;
            }
        }

        // Get current network info
        function getCurrentNetworkInfo() {
            return {
                ...CURRENT_NETWORK,
                isTestnet: CURRENT_NETWORK === NETWORKS.ARBITRUM_SEPOLIA
            };
        }


        // Power-up functions with contract integration
        async function upgradeTapPower() {
            const cost = gameState.tapPowerCost;
            if (gameState.totalTaps < cost) {
                showNotification('Not enough taps to upgrade!', '#ff3b30');
                return;
            }

            // Try blockchain upgrade if wallet connected and contract available
            if (isWalletConnected && gameContract && typeof window.ethers !== 'undefined') {
                try {
                    showNotification('Upgrading Tap Power on blockchain...', '#ffd700');

                    // Get current on-chain taps
                    const playerStats = await gameContract.getPlayerStats(connectedAddress);
                    const onChainTaps = playerStats.totalTaps.toNumber();
                    
                    // Calculate new tap count after upgrade
                    const newTapCount = Math.max(gameState.totalTaps, onChainTaps + 1);
                    const tx = await gameContract.updateTaps(newTapCount);

                    showNotification('Transaction submitted, waiting for confirmation...', '#00bfff');
                    const receipt = await tx.wait();

                    if (receipt && receipt.status === 1) {
                        showNotification(`Tap Power upgrade recorded! TX: ${tx.hash.slice(0, 8)}...`, '#00ff00');

                        // Apply upgrade locally after successful contract interaction
                        applyTapPowerUpgrade(cost);
                        return;
                    } else {
                        throw new Error("Transaction failed");
                    }
                } catch (error) {
                    console.error('Blockchain upgrade failed:', error);
                    if (error.code === 4001) {
                        showNotification('Transaction rejected by user.', '#ff3b30');
                        return;
                    } else if (error.message && error.message.includes('insufficient funds')) {
                        showNotification('Insufficient funds for transaction.', '#ff3b30');
                        return;
                    } else {
                        showNotification('Blockchain upgrade failed. Using local upgrade.', '#ff9900');
                    }
                }
            }

            // Local upgrade (fallback or when wallet not connected)
            applyTapPowerUpgrade(cost);
        }

        function applyTapPowerUpgrade(cost) {
            gameState.totalTaps -= cost;
            gameState.tapPowerLevel++;
            gameState.tapPowerCost = Math.floor(cost * 1.5);
            gameState.tapPower = gameState.tapPowerLevel;

            updateUI();
            saveGameState();
            showNotification(`Tap Power Level ${gameState.tapPowerLevel}!`, '#ffd700');
        }

        async function upgradeMaxEnergy() {
            const cost = gameState.energyCost;
            if (gameState.totalTaps >= cost) {
                if (isWalletConnected && gameContract && typeof window.ethers !== 'undefined') {
                    try {
                        showNotification('Upgrading Max Energy on blockchain...', '#00bfff');

                        // Get current on-chain taps and ensure new count is higher
                        const playerStats = await gameContract.getPlayerStats(connectedAddress);
                        const onChainTaps = playerStats.totalTaps.toNumber();
                        const newTapCount = Math.max(gameState.totalTaps, onChainTaps + 1);
                        const tx = await gameContract.updateTaps(newTapCount);

                        showNotification('Transaction submitted, waiting for confirmation...', '#00bfff');
                        const receipt = await tx.wait();

                        if (receipt && receipt.status === 1) {
                            showNotification(`Max Energy upgrade recorded! TX: ${tx.hash.slice(0, 8)}...`, '#00ff00');

                            // Apply upgrade locally
                            applyMaxEnergyUpgrade(cost);
                            return;
                        } else {
                            throw new Error("Transaction failed");
                        }
                    } catch (error) {
                        console.error('Blockchain upgrade failed:', error);
                        if (error.code === 4001) {
                            showNotification('Transaction rejected by user.', '#ff3b30');
                        } else {
                            showNotification('Blockchain upgrade failed. Using local upgrade.', '#ff9900');
                            applyMaxEnergyUpgrade(cost);
                        }
                        return;
                    }
                } else {
                    // Local upgrade
                    applyMaxEnergyUpgrade(cost);
                }
            } else {
                showNotification('Not enough taps to upgrade!', '#ff3b30');
            }
        }

        function applyMaxEnergyUpgrade(cost) {
            gameState.totalTaps -= cost;
            gameState.energyLevel++;
            gameState.energyCost = Math.floor(cost * 1.5);
            gameState.maxEnergy = 1000 + (gameState.energyLevel - 1) * 200;
            gameState.energy = Math.min(gameState.energy, gameState.maxEnergy);

            updateUI();
            saveGameState();
            showNotification(`Max Energy: ${gameState.maxEnergy}!`, '#00bfff');
        }


        async function upgradeEnergyRegen() {
            const cost = gameState.regenCost;
            if (gameState.totalTaps >= cost) {
                if (isWalletConnected && gameContract && typeof window.ethers !== 'undefined') {
                    try {
                        showNotification('Upgrading Energy Regen on blockchain...', '#00ff00');

                        // Get current on-chain taps and ensure new count is higher
                        const playerStats = await gameContract.getPlayerStats(connectedAddress);
                        const onChainTaps = playerStats.totalTaps.toNumber();
                        const newTapCount = Math.max(gameState.totalTaps, onChainTaps + 1);
                        const tx = await gameContract.updateTaps(newTapCount);

                        showNotification('Transaction submitted, waiting for confirmation...', '#00bfff');
                        const receipt = await tx.wait();

                        if (receipt && receipt.status === 1) {
                            showNotification(`Energy Regen upgrade recorded! TX: ${tx.hash.slice(0, 8)}...`, '#00ff00');

                            // Apply upgrade locally
                            applyEnergyRegenUpgrade(cost);
                            return;
                        } else {
                            throw new Error("Transaction failed");
                        }
                    } catch (error) {
                        console.error('Blockchain upgrade failed:', error);
                        if (error.code === 4001) {
                            showNotification('Transaction rejected by user.', '#ff3b30');
                        } else {
                            showNotification('Blockchain upgrade failed. Using local upgrade.', '#ff9900');
                            applyEnergyRegenUpgrade(cost);
                        }
                        return;
                    }
                } else {
                    // Local upgrade
                    applyEnergyRegenUpgrade(cost);
                }
            } else {
                showNotification('Not enough taps to upgrade!', '#ff3b30');
            }
        }

        function applyEnergyRegenUpgrade(cost) {
            gameState.totalTaps -= cost;
            gameState.regenLevel++;
            gameState.regenCost = Math.floor(cost * 1.5);
            gameState.energyRegenRate = gameState.regenLevel;

            updateUI();
            saveGameState();
            showNotification(`+${gameState.regenLevel} Regen Speed!`, '#00ff00');
        }

        // Manual contract interaction function
        async function manualContractInteraction() {
            const cost = 1; // 1 tap cost for the sync operation

            if (gameState.totalTaps < cost) {
                showNotification('Need at least 1 tap!', '#ff3b30');
                return;
            }

            if (!isWalletConnected) {
                showNotification('Please connect your wallet first!', '#ff9900');
                return;
            }

            if (!gameContract || typeof window.ethers === 'undefined') {
                showNotification('Contract not initialized. Initializing now...', '#ff9900');
                await initializeContract();

                // Check again after initialization attempt
                if (!gameContract) {
                    showNotification('Failed to initialize contract. Please check network and try again.', '#ff3b30');
                    return;
                }
            }

            try {
                showNotification('Checking on-chain state...', '#00bfff');

                // Verify we're on the correct network first
                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const network = await provider.getNetwork();
                const currentChainId = '0x' + network.chainId.toString(16);
                
                console.log('Current chain ID:', currentChainId, 'Expected:', CURRENT_NETWORK.chainId);
                
                if (currentChainId !== CURRENT_NETWORK.chainId) {
                    showNotification(`Please switch to ${CURRENT_NETWORK.name}`, '#ff9900');
                    await switchToTargetNetwork();
                    return;
                }

                // Verify account balance for gas
                const balance = await provider.getBalance(connectedAddress);
                const balanceEth = parseFloat(window.ethers.utils.formatEther(balance));
                console.log('Account balance:', balanceEth, 'ETH');
                
                if (balanceEth < 0.001) {
                    showNotification('You need at least 0.001 ETH for gas fees', '#ff3b30');
                    return;
                }

                // Get current on-chain taps for this player
                const playerStats = await gameContract.getPlayerStats(connectedAddress);
                const onChainTaps = playerStats.totalTaps.toNumber();
                
                console.log('Current local taps:', gameState.totalTaps);
                console.log('Current on-chain taps:', onChainTaps);

                // Only sync if we have more taps locally than on-chain
                if (gameState.totalTaps <= onChainTaps) {
                    showNotification('Your taps are already synced or on-chain value is higher!', '#ff9900');
                    // Update local state to match on-chain state if it's higher
                    if (onChainTaps > gameState.totalTaps) {
                        gameState.totalTaps = onChainTaps;
                        updateUI();
                        saveGameState();
                        showNotification('Local taps updated to match blockchain!', '#30d158');
                    }
                    return;
                }

                showNotification('Syncing with blockchain...', '#00bfff');

                // Send current tap count to blockchain (it's higher than on-chain)
                const newTapCount = gameState.totalTaps;

                // Estimate gas first
                const gasEstimate = await gameContract.estimateGas.updateTaps(newTapCount);
                const gasLimit = gasEstimate.mul(120).div(100); // Add 20% buffer

                // Send transaction to update taps on blockchain
                const tx = await gameContract.updateTaps(newTapCount, {
                    gasLimit: gasLimit
                });

                showNotification(`Transaction submitted! Hash: ${tx.hash.slice(0, 8)}...`, '#ffd700');

                // Wait for confirmation
                const receipt = await tx.wait();

                if (receipt && receipt.status === 1) {
                    // Apply the cost deduction locally after successful transaction
                    gameState.totalTaps = Math.max(0, gameState.totalTaps - cost);
                    updateUI();
                    saveGameState();

                    showNotification(`✅ Blockchain sync complete! TX: ${tx.hash.slice(0, 8)}...`, '#00ff00');
                    console.log('Manual contract interaction successful:', {
                        txHash: tx.hash,
                        gasUsed: receipt.gasUsed.toString(),
                        sentTapCount: newTapCount,
                        remainingTaps: gameState.totalTaps,
                        costDeducted: cost
                    });
                } else {
                    throw new Error("Transaction failed");
                }

            } catch (error) {
                console.error('Manual contract interaction failed:', error);

                // Improved error handling to prevent the "in" operator error
                let errorMessage = 'Unknown error';
                let errorCode = null;

                try {
                    // Safely extract error information
                    if (error) {
                        if (typeof error === 'string') {
                            errorMessage = error;
                        } else if (typeof error === 'object') {
                            errorCode = error.code || null;
                            
                            // Try multiple ways to get the error message
                            if (error.message) {
                                errorMessage = error.message;
                            } else if (error.reason) {
                                errorMessage = error.reason;
                            } else if (error.data && error.data.message) {
                                errorMessage = error.data.message;
                            } else if (error.error) {
                                if (typeof error.error === 'string') {
                                    errorMessage = error.error;
                                } else if (error.error.message) {
                                    errorMessage = error.error.message;
                                }
                            } else {
                                errorMessage = String(error);
                            }
                        } else {
                            errorMessage = String(error);
                        }
                    }
                } catch (parseError) {
                    console.error('Error parsing error:', parseError);
                    errorMessage = 'Failed to parse error details';
                }

                // Handle specific error cases with more precise detection
                if (errorCode === 4001) {
                    showNotification('Transaction rejected by user.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('user rejected') || errorMessage.toLowerCase().includes('denied')) {
                    showNotification('Transaction rejected by user.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('new count must be higher') || errorMessage.toLowerCase().includes('already synced')) {
                    showNotification('Your local taps are already synced to blockchain!', '#ff9900');
                } else if (errorMessage.toLowerCase().includes('execution reverted')) {
                    showNotification('Contract execution failed. Please try again.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('cannot use \'in\' operator') || errorMessage.toLowerCase().includes('search for \'error\'')) {
                    showNotification('Network connection issue. Please check your wallet connection and try again.', '#ff9900');
                } else if (errorCode === -32603 && errorMessage.toLowerCase().includes('insufficient funds for gas')) {
                    showNotification('Insufficient ETH for gas fees. Please add ETH to your wallet.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('insufficient funds') && errorMessage.toLowerCase().includes('gas')) {
                    showNotification('Insufficient ETH for gas fees. Please add ETH to your wallet.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('network') || errorMessage.toLowerCase().includes('chain')) {
                    showNotification('Network error. Please check your connection and try again.', '#ff3b30');
                } else if (errorMessage.toLowerCase().includes('missing provider') || errorMessage.toLowerCase().includes('provider')) {
                    showNotification('Wallet connection lost. Please reconnect your wallet.', '#ff9900');
                } else {
                    // For the specific error you're seeing, provide a more helpful message
                    if (errorMessage.includes('in') && errorMessage.includes('operator') && errorMessage.includes('search')) {
                        showNotification('Connection error. Please refresh and try again.', '#ff9900');
                    } else {
                        showNotification(`Sync failed: ${errorMessage.slice(0, 60)}... Please try again.`, '#ff3b30');
                    }
                }
            }
        }

        // Attach event listeners to power-up cards
        function setupPowerupListeners() {
            document.getElementById('tapPowerUpgrade').addEventListener('click', upgradeTapPower);
            document.getElementById('energyUpgrade').addEventListener('click', upgradeMaxEnergy);
            document.getElementById('regenUpgrade').addEventListener('click', upgradeEnergyRegen);
            // Add listener for level upgrade if it has a specific function
            document.getElementById('levelUpgrade').addEventListener('click', () => {
                const cost = gameState.levelUpCost;
                if (gameState.totalTaps >= gameState.levelUpCost) { // Use the calculated cost
                    // Logic for level up - potentially based on a different contract interaction
                    showNotification('Level Up feature not fully implemented yet.', '#ff9900');
                } else {
                    showNotification('Not enough taps to level up!', '#ff3b30');
                }
            });
            // Add listener for the new manual contract interaction power-up
            document.getElementById('manualContractSync').addEventListener('click', manualContractInteraction);
        }

        // Update current network information and display
        async function updateCurrentNetworkInfo() {
            if (typeof window.ethereum === 'undefined') {
                console.warn('Ethereum provider not detected. Cannot update network info.');
                return;
            }
            
            try {
                // Ensure ethers is loaded
                if (typeof window.ethers === 'undefined') {
                    await loadEthersLibrary();
                }
                
                if (typeof window.ethers === 'undefined') {
                    console.warn('ethers.js not available for network info');
                    return;
                }

                const provider = new window.ethers.providers.Web3Provider(window.ethereum);
                const network = await provider.getNetwork();
                const chainId = '0x' + network.chainId.toString(16);

                let networkInfo = { ...CURRENT_NETWORK, isTestnet: CURRENT_NETWORK === NETWORKS.ARBITRUM_SEPOLIA };

                if (chainId === NETWORKS.ARBITRUM_ONE.chainId) {
                    networkInfo = { ...NETWORKS.ARBITRUM_ONE, isTestnet: false };
                } else if (chainId === NETWORKS.ARBITRUM_SEPOLIA.chainId) {
                    networkInfo = { ...NETWORKS.ARBITRUM_SEPOLIA, isTestnet: true };
                } else {
                    // Handle unknown networks more gracefully
                    networkInfo = {
                        chainId: chainId,
                        name: network.name || `Unknown Network`,
                        rpcUrls: [],
                        blockExplorerUrls: [],
                        contractAddress: null,
                        isTestnet: false
                    };
                    showNotification(`Connected to unsupported network. Please switch to Arbitrum Sepolia.`, '#ff9900');
                }
                
                CURRENT_NETWORK = networkInfo;
                updateNetworkStatus(networkInfo);
                
            } catch (error) {
                console.error('Error updating current network info:', error);
                
                // Graceful fallback - use current network as default
                updateNetworkStatus({
                    ...CURRENT_NETWORK,
                    isTestnet: CURRENT_NETWORK === NETWORKS.ARBITRUM_SEPOLIA
                });
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Initializing ARBITAP game...');

            loadGameState();
            initializeElements();

            // Load ethers.js first (non-blocking)
            loadEthersLibrary()
                .then(() => {
                    console.log('ethers.js loaded successfully');
                })
                .catch((error) => {
                    console.warn('Failed to load ethers.js:', error);
                    showNotification('Blockchain features disabled', '#ff9900');
                });

            // Update network status initially
            await updateCurrentNetworkInfo();

            // Wallet connection setup
            const walletStatus = document.getElementById('walletStatus');
            if (walletStatus) {
                walletStatus.addEventListener('click', connectWallet);
            }

            // Check if wallet is already connected
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        updateWalletStatus(true, accounts[0]);
                        // Force contract initialization after wallet connection
                        setTimeout(async () => {
                            await initializeContract();
                        }, 1000);
                    } else {
                        updateWalletStatus(false);
                    }
                } catch (error) {
                    console.error('Error checking wallet connection:', error);
                    updateWalletStatus(false);
                }

                // Listen for account changes
                window.ethereum.on('accountsChanged', async function(accounts) {
                    if (accounts.length > 0) {
                        updateWalletStatus(true, accounts[0]);
                        // Re-initialize contract when account changes
                        setTimeout(async () => {
                            await initializeContract();
                        }, 500);
                    } else {
                        updateWalletStatus(false);
                        gameContract = null; // Clear contract instance if wallet disconnected
                        showNotification('Wallet disconnected', '#ff9900');
                    }
                });

                // Listen for chain changes
                window.ethereum.on('chainChanged', async function(chainId) {
                    console.log('Chain changed to:', chainId);
                    await updateCurrentNetworkInfo(); // Update network display
                    // Re-initialize contract for the new chain
                    setTimeout(async () => {
                        await initializeContract();
                    }, 1000);
                });
            } else {
                console.warn('MetaMask or other Web3 provider not detected.');
                updateWalletStatus(false);
                showNotification('Please install MetaMask to use blockchain features', '#ff9900');
            }

            // Set up event listeners for power-ups
            setupPowerupListeners();

            // Set up tap button listener
            if (elements.tapButton) {
                elements.tapButton.addEventListener('click', handleTap);
                elements.tapButton.addEventListener('touchstart', handleTap);
                console.log('Tap button listeners attached');
            }

            // Set up leaderboard toggle
            if (elements.leaderboardToggle) {
                elements.leaderboardToggle.addEventListener('click', function() {
                    const content = elements.leaderboardContent;
                    const toggle = elements.leaderboardToggle;

                    if (content.classList.contains('expanded')) {
                        content.classList.remove('expanded');
                        toggle.classList.remove('expanded');
                    } else {
                        content.classList.add('expanded');
                        toggle.classList.add('expanded');
                    }
                });
                console.log('Leaderboard toggle listener attached');
            }

            // Initial UI updates
            updateUI();

            // Start energy regeneration
            startEnergyRegen();

            console.log('Game initialized');
        });

        // Auto-save every 30 seconds
        setInterval(() => {
            saveGameState();
        }, 30000);

        // Save on page unload
        window.addEventListener('beforeunload', () => {
            saveGameState();
        });

        // Add keyframes for animations if not already present
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translateX(-50%) translateY(-30px); opacity: 0; }
                to { transform: translateX(-50%) translateY(0); opacity: 1; }
            }
            @keyframes slideUp {
                from { transform: translateX(-50%) translateY(0); opacity: 1; }
                to { transform: translateX(-50%) translateY(-30px); opacity: 0; }
            }
        `;
        // Only append if not already in the document (e.g., from initial load)
        if (!document.querySelector('style[data-keyframes]')) {
            style.setAttribute('data-keyframes', 'true');
            document.head.appendChild(style);
        }

        // Enhanced ethers.js loading with single reliable CDN and better error handling
        async function loadEthersLibrary() {
            if (window.ethers) {
                console.log('ethers.js already loaded');
                return true;
            }

            console.log('Loading ethers.js...');

            try {
                const success = await loadScriptFromCDN('https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js');
                if (success && window.ethers) {
                    console.log('ethers.js loaded successfully');
                    return true;
                }
            } catch (error) {
                console.log('Failed to load ethers.js:', error);
            }

            console.log('Failed to load ethers.js');
            return false;
        }

        // Improved script loading with better cleanup
        function loadScriptFromCDN(url, timeout = 15000) {
            return new Promise((resolve, reject) => {
                // Remove any existing failed scripts
                const existingScripts = document.querySelectorAll(`script[src*="ethers"]`);
                existingScripts.forEach(script => {
                    if (!window.ethers) {
                        script.remove();
                    }
                });

                if (window.ethers) {
                    resolve(true);
                    return;
                }

                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = url;
                script.async = true;

                const timeoutId = setTimeout(() => {
                    console.log(`Timeout loading ethers.js`);
                    script.remove();
                    reject(new Error(`Timeout loading ethers.js`));
                }, timeout);

                script.onload = () => {
                    clearTimeout(timeoutId);
                    if (window.ethers) {
                        console.log(`ethers.js loaded successfully`);
                        resolve(true);
                    } else {
                        script.remove();
                        reject(new Error('ethers.js not available after load'));
                    }
                };

                script.onerror = (error) => {
                    clearTimeout(timeoutId);
                    console.log(`Failed to load ethers.js:`, error);
                    script.remove();
                    reject(error);
                };

                document.head.appendChild(script);
            });
        }
    </script>
</body>
</html>